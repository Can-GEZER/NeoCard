rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ====================================
    // Helper Functions
    // ====================================
    
    /**
     * Check if user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null;
    }
    
    /**
     * Check if the authenticated user owns the resource
     */
    function isOwner(uid) {
      return isAuthenticated() && request.auth.uid == uid;
    }
    
    /**
     * Validate email format
     * RFC compliant email validation
     */
    function isValidEmail(email) {
      return email is string
        && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')
        && email.size() > 0
        && email.size() <= 100;
    }
    
    /**
     * Validate string length
     */
    function isValidLength(text, maxLength) {
      return text.size() <= maxLength;
    }
    
    /**
     * Check if the request is from server (Cloud Functions)
     * Server requests have admin privileges
     */
    function isServer() {
      return request.auth.token.admin == true;
    }
    
    // ====================================
    // User Documents Rules
    // ====================================
    
    /**
     * /users/{uid}
     * Read/Write: Only by authenticated user who owns the document
     * REQUIREMENT: Authentication required for all /users paths
     */
    match /users/{uid} {
      // Require authentication for all operations
      allow read: if isAuthenticated() && isOwner(uid);
      
      // Require authentication and validate data
      allow create, update: if isAuthenticated() 
        && isOwner(uid)
        && validateUserData(request.resource.data);
      
      // Require authentication for delete
      allow delete: if isAuthenticated() && isOwner(uid);
      
      /**
       * Validate user data
       * Requirements:
       * - Name length < 100
       * - Email format validation
       */
      function validateUserData(data) {
        return data.keys().hasAll(['id', 'email', 'displayName'])
          && (data.email == null || data.email == '' || isValidEmail(data.email))
          && (data.displayName == null || isValidLength(data.displayName, 100))
          && (data.displayName == null || data.displayName.size() > 0);
      }
      
      // ====================================
      // User Cards Subcollection Rules
      // ====================================
      
      /**
       * /users/{uid}/cards/{cardId}
       * Read/Write: Only by authenticated user who owns the card
       * REQUIREMENT: Authentication required for all /cards paths
       */
      match /cards/{cardId} {
        // Require authentication - only owner can read
        allow read: if isAuthenticated() && isOwner(uid);
        
        // Require authentication and validate data
        allow create, update: if isAuthenticated() 
          && isOwner(uid)
          && validateCardData(request.resource.data);
        
        // Require authentication for delete
        allow delete: if isAuthenticated() && isOwner(uid);
        
        /**
         * Validate card data
         * Requirements:
         * - Name length < 100
         * - Email format check
         * - All field length validations
         */
        function validateCardData(data) {
          return data.keys().hasAll(['name', 'surname', 'email'])
            // Name validation: required, non-empty, max 100 chars
            && data.name is string
            && data.name.size() > 0
            && isValidLength(data.name, 100)
            // Surname validation: non-empty if provided, max 100 chars
            && data.surname is string
            && (data.surname == '' || isValidLength(data.surname, 100))
            // Email validation: format check if provided
            && data.email is string
            && (data.email == '' || isValidEmail(data.email))
            // Optional field validations
            && (data.company == null || data.company == '' || (data.company is string && isValidLength(data.company, 200)))
            && (data.title == null || data.title == '' || (data.title is string && isValidLength(data.title, 200)))
            && (data.phone == null || data.phone == '' || (data.phone is string && isValidLength(data.phone, 20)))
            && (data.website == null || data.website == '' || (data.website is string && isValidLength(data.website, 500)))
            && (data.linkedin == null || data.linkedin == '' || (data.linkedin is string && isValidLength(data.linkedin, 200)))
            && (data.instagram == null || data.instagram == '' || (data.instagram is string && isValidLength(data.instagram, 200)))
            && (data.twitter == null || data.twitter == '' || (data.twitter is string && isValidLength(data.twitter, 200)))
            && (data.facebook == null || data.facebook == '' || (data.facebook is string && isValidLength(data.facebook, 200)))
            && (data.github == null || data.github == '' || (data.github is string && isValidLength(data.github, 200)))
            && (data.bio == null || data.bio == '' || (data.bio is string && isValidLength(data.bio, 500)));
        }
      }
      
      // ====================================
      // User Notifications Subcollection Rules
      // ====================================
      
      /**
       * /users/{uid}/notifications/{notificationId}
       * Read/Write: Only by the authenticated user who owns the notification
       */
      match /notifications/{notificationId} {
        allow read: if isOwner(uid);
        allow write: if isOwner(uid);
      }
    }
    
    // ====================================
    // Public Cards Collection Rules
    // ====================================
    
    /**
     * /public_cards/{cardId}
     * Read: Only when isPublic == true (anyone can read public cards)
     * Write: Only by authenticated card owner or server
     * REQUIREMENT: Read only when isPublic == true
     */
    match /public_cards/{cardId} {
      // Allow read ONLY if card isPublic == true
      // Check both in existing resource and new resource data
      allow read: if resource != null 
        && resource.data.isPublic == true;
      
      // Allow create/update if user owns the card or is server
      // Require authentication and validate isPublic flag
      allow create, update: if isAuthenticated() 
        && (request.auth.uid == request.resource.data.userId || isServer())
        && request.resource.data.keys().hasAll(['id', 'userId', 'isPublic'])
        && request.resource.data.isPublic == true;
      
      // Allow delete only by authenticated card owner
      allow delete: if isAuthenticated() 
        && resource != null
        && request.auth.uid == resource.data.userId;
    }
    
    // ====================================
    // Card Statistics Collection Rules
    // ====================================
    
    /**
     * /card_statistics/{cardId}
     * Read: Only by authenticated card owner
     * Write: DISALLOWED from clients - Only by server (Cloud Functions)
     * REQUIREMENT: No client writes allowed
     */
    match /card_statistics/{cardId} {
      // Allow read only if authenticated and user owns the card
      allow read: if isAuthenticated() 
        && resource != null
        && request.auth.uid == resource.data.cardOwnerId;
      
      // DISALLOW all writes from clients - Only server can write
      allow create, update: if isServer();
      
      // Allow delete only by server (card owner cannot delete statistics)
      allow delete: if isServer();
    }
    
    // ====================================
    // Card Analytics Events Collection Rules
    // ====================================
    
    /**
     * /card_analytics/{eventId}
     * Read: Only by card owner
     * Write: Anyone (for tracking views, clicks, etc.)
     */
    match /card_analytics/{eventId} {
      // Allow read only by card owner
      allow read: if isAuthenticated() 
        && request.auth.uid == resource.data.cardOwnerId;
      
      // Allow create for tracking events (anonymous or authenticated)
      allow create: if request.resource.data.keys().hasAll(['cardId', 'cardOwnerId', 'eventType', 'timestamp'])
        && request.resource.data.timestamp == request.time;
      
      // Allow update/delete only by server
      allow update, delete: if isServer();
    }
    
    // ====================================
    // Connection Requests Collection Rules
    // ====================================
    
    /**
     * /connection_requests/{requestId}
     * Read/Write: By sender or receiver
     */
    match /connection_requests/{requestId} {
      // Allow read if user is sender or receiver
      allow read: if isAuthenticated() 
        && (request.auth.uid == resource.data.fromUserId 
          || request.auth.uid == resource.data.toUserId);
      
      // Allow create if user is the sender
      allow create: if isAuthenticated() 
        && request.auth.uid == request.resource.data.fromUserId
        && request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'cardId', 'status', 'createdAt'])
        && request.resource.data.status == 'pending';
      
      // Allow update if user is receiver (to accept/reject)
      allow update: if isAuthenticated() 
        && request.auth.uid == resource.data.toUserId
        && request.resource.data.status in ['accepted', 'rejected'];
      
      // Allow delete by sender or receiver
      allow delete: if isAuthenticated() 
        && (request.auth.uid == resource.data.fromUserId 
          || request.auth.uid == resource.data.toUserId);
    }
    
    // ====================================
    // Promo Codes Collection Rules
    // ====================================
    
    /**
     * /promo_codes/{code}
     * Read: Anyone authenticated
     * Write: Only by server/admin
     */
    match /promo_codes/{code} {
      allow read: if isAuthenticated();
      allow write: if isServer();
    }
    
    // ====================================
    // Deny all other access
    // ====================================
    
    // Default deny for all other paths
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

